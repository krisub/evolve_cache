{"id": "63ec9c5e-213a-4b10-b73f-d665d4775c98", "code": "#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * Adaptive: Heavily reward hot small objects, sublinear penalty for medium,\n   * and stronger log-based bias for large objects. Reduce overall scaling for\n   * more granularity among frequent, medium-size objects.\n   */\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    constexpr double SMALL_SCALE = 1.8e5, LARGE_SCALE = 4.0e5, MID_SCALE = 9.5e4;\n    if (size == 0) return pri_last_evict + (freq + 2) * SMALL_SCALE;\n    if (size <= 4096) {\n      // Hot small objects (\u22644KB) get strong freq boost, lighter size penalty\n      return pri_last_evict + std::pow(freq + 2.5, 1.25) * SMALL_SCALE / std::pow(size + 1.0, 0.35);\n    }\n    if (size > 1024 * 1024) {\n      // Very large objects: log-freq, heavier log-size penalty\n      return pri_last_evict + std::pow(std::log2(freq + 1.5), 1.13) * LARGE_SCALE / std::pow(std::log2(size + 16.0), 1.12);\n    }\n    // Medium objects: sublinear freq and sublinear size, lower scale to help discrimination among mediums\n    return pri_last_evict + std::pow(freq + 1.2, 1.07) * MID_SCALE / std::pow(size + 2.0, 0.77);\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // Insert \"virtual freq\" bonus:\n    // - Tiny objects: +2 (favor tiny, hot objects)\n    // - Small (\u226464KB): +1 (minor boost)\n    // - Large (>1MB): +2 (favor survival if accessed again)\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size <= 4096) adj_freq += 2;\n    else if (obj_size <= 65536) adj_freq += 1;\n    if (obj_size > 1024 * 1024) adj_freq += 2;\n\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};", "language": "python", "parent_id": "26397b31-db48-49a8-b984-e5b6066af1cb", "generation": 4, "timestamp": 1763087022.536013, "iteration_found": 73, "metrics": {"combined_score": 0.8452999999999999, "miss_ratio_4": 0.4581, "miss_ratio_45": 0.2902, "miss_ratio_450": 0.1547}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 27 lines with 21 lines\nChange 2: Replace 25 lines with 26 lines", "parent_metrics": {"combined_score": 0.8455, "miss_ratio_4": 0.3898, "miss_ratio_45": 0.2706, "miss_ratio_450": 0.1545}, "island": 2}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}