{"id": "92285956-ba13-4f53-a365-952a0ea2cc66", "code": "#include <cstdint>\n#include <unordered_map>\n#include <set>\n#include <vector>\n\ntypedef uint64_t obj_id_t;\n\n/*\n * GDSF-like: Prioritize frequently-accessed AND small objects using GreedyDual-Size-Frequency.\n * This policy gives a bonus to frequency per size (\"value density\") and ages objects with every eviction.\n * It avoids pure-LFU's stagnation and speeds adaptation to changing workloads.\n */\nclass CacheManager {\nprivate:\n    struct PQNode {\n        double priority;\n        uint64_t timestamp;\n        uint64_t freq;\n        uint64_t size;\n        obj_id_t obj_id;\n        PQNode(double p, uint64_t ts, uint64_t f, uint64_t s, obj_id_t id)\n            : priority(p), timestamp(ts), freq(f), size(s), obj_id(id) {}\n        bool operator<(const PQNode &o) const {\n            if (priority != o.priority) return priority < o.priority;\n            if (timestamp != o.timestamp) return timestamp < o.timestamp;\n            return obj_id < o.obj_id;\n        }\n    };\n\n    std::unordered_map<obj_id_t, std::set<PQNode>::iterator> obj2iter;\n    std::unordered_map<obj_id_t, std::pair<uint64_t, uint64_t>> obj2freqsize; // id -> (freq, size)\n    std::set<PQNode> pq;\n    double last_evict_priority = 0.0;\n    uint64_t ts = 0;\n\n    double calc_priority(uint64_t freq, uint64_t size) {\n        if (size == 0) size = 1;\n        return last_evict_priority + (double(freq) * 1.0e6 / size);\n    }\n\npublic:\n    bool find(obj_id_t obj_id) {\n        auto it = obj2iter.find(obj_id);\n        if (it == obj2iter.end()) return false;\n        PQNode node = *(it->second);\n        pq.erase(it->second);\n        node.freq += 1;\n        node.timestamp = ++ts;\n        node.priority = calc_priority(node.freq, node.size);\n        auto iter = pq.insert(node).first;\n        obj2iter[obj_id] = iter;\n        obj2freqsize[obj_id] = {node.freq, node.size};\n        return true;\n    }\n\n    void insert(obj_id_t obj_id, uint64_t obj_size) {\n        auto it = obj2iter.find(obj_id);\n        if (it != obj2iter.end()) {\n            find(obj_id);\n            return;\n        }\n        uint64_t freq = 1;\n        uint64_t cur_ts = ++ts;\n        double pri = calc_priority(freq, obj_size);\n        PQNode node(pri, cur_ts, freq, obj_size, obj_id);\n        auto iter = pq.insert(node).first;\n        obj2iter[obj_id] = iter;\n        obj2freqsize[obj_id] = {freq, obj_size};\n    }\n\n    obj_id_t evict() {\n        if (pq.empty()) return 0;\n        auto it = pq.begin();\n        obj_id_t victim = it->obj_id;\n        last_evict_priority = it->priority;\n        pq.erase(it);\n        obj2iter.erase(victim);\n        obj2freqsize.erase(victim);\n\n        // Aging: Halve all remaining frequencies (minimum 1), to avoid stale hot objects dominating forever\n        std::vector<std::pair<obj_id_t, PQNode>> to_update;\n        for (auto& kv : obj2iter) {\n            obj_id_t id = kv.first;\n            auto pqit = kv.second;\n            PQNode node = *pqit;\n            pq.erase(pqit);\n            if (node.freq > 1) node.freq = (node.freq + 1) / 2;\n            node.priority = calc_priority(node.freq, node.size);\n            node.timestamp = ++ts;\n            to_update.push_back({id, node});\n        }\n        for (auto& x : to_update) {\n            auto pqit = pq.insert(x.second).first;\n            obj2iter[x.first] = pqit;\n            obj2freqsize[x.first] = {x.second.freq, x.second.size};\n        }\n\n        return victim;\n    }\n};", "language": "python", "parent_id": "98f21a6a-8156-42b8-9cd2-fae93b7cad42", "generation": 9, "timestamp": 1763754561.8739731, "iteration_found": 95, "metrics": {"combined_score": -Infinity}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 70 lines with 100 lines", "parent_metrics": {"combined_score": -Infinity}, "island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}