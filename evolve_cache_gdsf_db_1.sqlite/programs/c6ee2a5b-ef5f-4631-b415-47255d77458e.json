{"id": "c6ee2a5b-ef5f-4631-b415-47255d77458e", "code": "#include <cstdint>\n#include <unordered_map>\n#include <set>\n\ntypedef uint64_t obj_id_t;\n\n// LFU+Size-Aware: Uses frequency, but for ties, prefers to evict LARGER objects (so we keep small hot objects).\n// This variant adds a \"recently evicted priority\" (GDSF L value) to the mix for more adaptation to changing workloads.\nclass CacheManager {\nprivate:\n    struct LFUNode {\n        double priority;   // Priority value for eviction ordering (incorporates freq and size with L aging)\n        uint64_t timestamp;\n        uint64_t freq;\n        uint64_t size;\n        obj_id_t obj_id;\n        LFUNode(double pri, uint64_t ts, uint64_t f, uint64_t s, obj_id_t id)\n            : priority(pri), timestamp(ts), freq(f), size(s), obj_id(id) {}\n        // Lower priority first. Break ties by timestamp, then by obj_id.\n        bool operator<(const LFUNode &o) const {\n            if (priority != o.priority) return priority < o.priority;\n            if (timestamp != o.timestamp) return timestamp < o.timestamp;\n            return obj_id < o.obj_id;\n        }\n    };\n\n    std::unordered_map<obj_id_t, std::set<LFUNode>::iterator> obj2iter;\n    std::unordered_map<obj_id_t, uint64_t> obj2size;\n    std::unordered_map<obj_id_t, uint64_t> obj2freq;\n    std::set<LFUNode> lfu_set;\n    uint64_t time_counter = 0;\n    double last_evict_pri = 0.0;\n\n    double calc_priority(uint64_t freq, uint64_t size) {\n        // GDSF-inspired: L + freq / size (scaled)\n        if (size == 0) return last_evict_pri + freq * 1e6;\n        return last_evict_pri + (double(freq) * 1e6 / double(size));\n    }\n\npublic:\n    bool find(obj_id_t obj_id) {\n        auto it = obj2iter.find(obj_id);\n        if (it == obj2iter.end()) return false;\n        auto node = *(it->second);\n        lfu_set.erase(it->second);\n\n        uint64_t new_freq = node.freq + 1;\n        obj2freq[obj_id] = new_freq;\n        double new_pri = calc_priority(new_freq, node.size);\n        auto iter = lfu_set.insert(LFUNode(new_pri, ++time_counter, new_freq, node.size, node.obj_id)).first;\n        obj2iter[obj_id] = iter;\n        obj2size[obj_id] = node.size; // Ensure size up-to-date for future access\n        return true;\n    }\n\n    void insert(obj_id_t obj_id, uint64_t obj_size) {\n        auto it = obj2iter.find(obj_id);\n        if (it != obj2iter.end()) {\n            // If re-insert, treat as access, but update size in case caller expects changed size.\n            if (obj2size[obj_id] != obj_size) {\n                auto old_iter = it->second;\n                auto node = *old_iter;\n                lfu_set.erase(old_iter);\n                uint64_t freq = node.freq + 1;\n                obj2freq[obj_id] = freq;\n                obj2size[obj_id] = obj_size;\n                double pri = calc_priority(freq, obj_size);\n                auto iter2 = lfu_set.insert(LFUNode(pri, ++time_counter, freq, obj_size, obj_id)).first;\n                obj2iter[obj_id] = iter2;\n            } else {\n                find(obj_id);\n            }\n            return;\n        }\n        obj2size[obj_id] = obj_size;\n        obj2freq[obj_id] = 1;\n        double pri = calc_priority(1, obj_size);\n        LFUNode node(pri, ++time_counter, 1, obj_size, obj_id);\n        auto iter = lfu_set.insert(node).first;\n        obj2iter[obj_id] = iter;\n    }\n\n    obj_id_t evict() {\n        if (lfu_set.empty()) return 0;\n        auto it = lfu_set.begin();\n        obj_id_t victim = it->obj_id;\n        last_evict_pri = it->priority;\n        lfu_set.erase(it);\n        obj2iter.erase(victim);\n        obj2size.erase(victim);\n        obj2freq.erase(victim);\n\n        // Optionally apply frequency aging to avoid stale frequency dominance.\n        // Here, every 16 evictions, decay freq > 8 to 7/8. Also, update priorities after aging.\n        static uint64_t evict_count = 0;\n        if (++evict_count % 16 == 0) {\n            for (auto& kv : obj2iter) {\n                obj_id_t oid = kv.first;\n                auto iter = kv.second;\n                auto node = *iter;\n                uint64_t old_freq = obj2freq[oid];\n                if (old_freq > 8) {\n                    uint64_t new_freq = (old_freq * 7) / 8;\n                    if (new_freq < 1) new_freq = 1;\n                    obj2freq[oid] = new_freq;\n                    lfu_set.erase(iter);\n                    double pri = calc_priority(new_freq, obj2size[oid]);\n                    auto new_iter = lfu_set.insert(LFUNode(pri, ++time_counter, new_freq, obj2size[oid], oid)).first;\n                    obj2iter[oid] = new_iter;\n                }\n            }\n        }\n\n        return victim;\n    }\n};", "language": "python", "parent_id": "3cb27f12-79c9-4c40-ba8b-087ffc61b99c", "generation": 4, "timestamp": 1763753711.0519211, "iteration_found": 66, "metrics": {"combined_score": -Infinity}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 13 lines with 14 lines\nChange 2: Replace 13 lines with 26 lines\nChange 3: Replace 11 lines with 33 lines", "parent_metrics": {"combined_score": -Infinity}, "island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}