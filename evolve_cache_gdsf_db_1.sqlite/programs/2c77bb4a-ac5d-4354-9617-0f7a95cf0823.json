{"id": "2c77bb4a-ac5d-4354-9617-0f7a95cf0823", "code": "#include <cstdint>\n#include <unordered_map>\n#include <set>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * GDSF-inspired cache: Frequency, size-aware, and with \"eviction history\" priority.\n * Uses (freq / size) with an 'L' value carried forward for frequency-size aging, similar to Greedy-Dual-Size-Frequency.\n * This aims to more dynamically balance access patterns and protect small hot objects while allowing recency/size/aging.\n */\nclass CacheManager {\nprivate:\n    struct PQNode {\n        double priority;   // L + freq/size, as in GDSF\n        uint64_t timestamp;\n        obj_id_t obj_id;\n        PQNode(double p, uint64_t t, obj_id_t id)\n            : priority(p), timestamp(t), obj_id(id) {}\n        bool operator<(const PQNode& o) const {\n            if (priority != o.priority) return priority < o.priority;\n            if (timestamp != o.timestamp) return timestamp < o.timestamp;\n            return obj_id < o.obj_id;\n        }\n    };\n\n    struct Entry {\n        uint64_t freq;\n        uint64_t size;\n        std::set<PQNode>::iterator pqit;\n    };\n\n    std::unordered_map<obj_id_t, Entry> table;\n    std::set<PQNode> pq;\n    double last_L = 0.0;\n    uint64_t req_count = 0;\n\n    double calc_pri(uint64_t freq, uint64_t size) {\n        // Avoid div by 0\n        if (size == 0) return last_L + freq * 1e6;\n        return last_L + (double(freq) * 1e6 / double(size));\n    }\n\npublic:\n    bool find(obj_id_t obj_id) {\n        auto it = table.find(obj_id);\n        if (it == table.end()) return false;\n        Entry& e = it->second;\n        pq.erase(e.pqit);\n        e.freq += 1;\n        double pri = calc_pri(e.freq, e.size);\n        PQNode newnode(pri, ++req_count, obj_id);\n        auto ins = pq.insert(newnode).first;\n        e.pqit = ins;\n        return true;\n    }\n\n    void insert(obj_id_t obj_id, uint64_t obj_size) {\n        auto it = table.find(obj_id);\n        if (it != table.end()) {\n            find(obj_id);\n            return;\n        }\n        uint64_t freq = 1;\n        double pri = calc_pri(freq, obj_size);\n        PQNode node(pri, ++req_count, obj_id);\n        auto pqit = pq.insert(node).first;\n        table[obj_id] = Entry{freq, obj_size, pqit};\n    }\n\n    obj_id_t evict() {\n        if (pq.empty()) return 0;\n        auto it = pq.begin();\n        obj_id_t victim = it->obj_id;\n        last_L = it->priority;\n        pq.erase(it);\n        table.erase(victim);\n        return victim;\n    }\n};", "language": "python", "parent_id": "f407eb59-cc43-4eae-87a4-56deb0f49a6f", "generation": 3, "timestamp": 1763752864.3049154, "iteration_found": 20, "metrics": {"combined_score": -Infinity}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 58 lines with 74 lines", "parent_metrics": {"combined_score": -Infinity}, "island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}