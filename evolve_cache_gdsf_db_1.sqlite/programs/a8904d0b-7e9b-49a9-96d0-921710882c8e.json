{"id": "a8904d0b-7e9b-49a9-96d0-921710882c8e", "code": "#include <cstdint>\n#include <set>\n#include <unordered_map>\ntypedef uint64_t obj_id_t;\n\n// Enhanced LFU with frequency aging and object size-aware tiebreaking.\n// Ages frequencies at each eviction to better adapt to changing workloads and recency.\nclass CacheManager {\nprivate:\n    struct LFUNode {\n        uint64_t freq;\n        uint64_t timestamp; // for tiebreak\n        uint64_t obj_size;\n        obj_id_t obj_id;\n        LFUNode(uint64_t f, uint64_t ts, uint64_t sz, obj_id_t id)\n            : freq(f), timestamp(ts), obj_size(sz), obj_id(id) {}\n        // Set ordering: freq first, then timestamp, then size (prefer to keep smaller hot objects), then obj_id\n        bool operator<(const LFUNode &o) const {\n            if (freq != o.freq) return freq < o.freq;\n            if (timestamp != o.timestamp) return timestamp < o.timestamp;\n            if (obj_size != o.obj_size) return obj_size > o.obj_size; // prefer to evict larger for same freq\n            return obj_id < o.obj_id;\n        }\n    };\n\n    // obj_id -> {size, {iterator in set}}\n    std::unordered_map<obj_id_t, std::pair<uint64_t, std::set<LFUNode>::iterator>> map;\n    std::set<LFUNode> lfu_set;\n    uint64_t time_counter = 0;\n\n    // Age all frequencies multiplicatively to \"forget\" old usage\n    void age_frequencies() {\n        // Create a vector to hold new nodes so we can reinsert\n        std::vector<std::tuple<obj_id_t, LFUNode>> aged_nodes;\n        for (auto& p : map) {\n            auto it = p.second.second;\n            LFUNode node = *it;\n            lfu_set.erase(it);\n            // Age frequency: halve, but at least 1 (ensures some memory)\n            node.freq = (node.freq > 1) ? (node.freq + 1) / 2 : 1;\n            aged_nodes.emplace_back(p.first, node);\n        }\n        // Reinsert aged nodes and update iterators\n        for (auto& entry : aged_nodes) {\n            obj_id_t oid = std::get<0>(entry);\n            LFUNode& node = std::get<1>(entry);\n            auto iter = lfu_set.insert(node).first;\n            map[oid].second = iter;\n        }\n    }\n\npublic:\n    bool find(obj_id_t obj_id) {\n        auto it = map.find(obj_id);\n        if (it == map.end()) return false;\n        uint64_t obj_size = it->second.first;\n        auto set_it = it->second.second;\n        LFUNode node = *set_it;\n        lfu_set.erase(set_it);\n        node.freq += 1;\n        node.timestamp = ++time_counter;\n        auto iter = lfu_set.insert(LFUNode(node.freq, node.timestamp, obj_size, obj_id)).first;\n        it->second.second = iter;\n        return true;\n    }\n\n    void insert(obj_id_t obj_id, uint64_t obj_size) {\n        auto it = map.find(obj_id);\n        if (it != map.end()) {\n            find(obj_id);\n            return;\n        }\n        LFUNode node(1, ++time_counter, obj_size, obj_id);\n        auto iter = lfu_set.insert(node).first;\n        map[obj_id] = std::make_pair(obj_size, iter);\n    }\n\n    obj_id_t evict() {\n        if (lfu_set.empty()) return 0;\n        auto it = lfu_set.begin();\n        obj_id_t victim = it->obj_id;\n        map.erase(victim);\n        lfu_set.erase(it);\n        // Frequency aging: periodically halve all frequencies after each eviction,\n        // ensures stale objects lose \"hot\" status over time (LFU+aging).\n        age_frequencies();\n        return victim;\n    }\n};", "language": "python", "parent_id": "0b21b0e6-8f78-4289-95b8-3b79af2fa134", "generation": 3, "timestamp": 1763752818.231621, "iteration_found": 21, "metrics": {"combined_score": -Infinity}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 64 lines with 89 lines", "parent_metrics": {"combined_score": -Infinity}, "island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}