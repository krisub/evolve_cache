{"id": "37b12f23-d000-4ecd-a7bc-86c22660fd5b", "code": "#include <cstdint>\n#include <unordered_map>\n#include <set>\n\ntypedef uint64_t obj_id_t;\n\nclass CacheManager {\nprivate:\n    // GDSF with frequency aging: track frequency and size for each object.\n    struct CacheObject {\n        uint64_t freq;\n        uint64_t size;\n        uint64_t timestamp;\n        std::set<std::tuple<double, uint64_t, obj_id_t>>::iterator pqit;\n    };\n    // Priority queue node: tuple for easy erase and reinsert\n    // (priority, timestamp, obj_id)\n    std::set<std::tuple<double, uint64_t, obj_id_t>> priority_set;\n    std::unordered_map<obj_id_t, CacheObject> cache_map;\n    uint64_t counter = 0;\n    double last_evict_pri = 0.0;\n\n    // Disable frequency aging and recency bonus to prevent unnecessary churn.\n    // Keep scoring strictly GDSF.\n    double calc_pri(uint64_t freq, uint64_t size) {\n        if (size == 0) return last_evict_pri + freq * 1e6;\n        return last_evict_pri + double(freq) * 1e6 / size;\n    }\n\npublic:\n    bool find(obj_id_t obj_id) {\n        auto it = cache_map.find(obj_id);\n        if (it == cache_map.end()) return false;\n        // Erase from set using iterator (O(log N))\n        priority_set.erase(it->second.pqit);\n        it->second.freq += 1;\n        it->second.timestamp = ++counter;\n        double new_pri = calc_pri(it->second.freq, it->second.size);\n        auto pqit = priority_set.insert({new_pri, it->second.timestamp, obj_id}).first;\n        it->second.pqit = pqit;\n        return true;\n    }\n\n    void insert(obj_id_t obj_id, uint64_t obj_size) {\n        auto it = cache_map.find(obj_id);\n        if (it != cache_map.end()) {\n            find(obj_id);\n            return;\n        }\n        uint64_t freq = 1;\n        uint64_t ts = ++counter;\n        double pri = calc_pri(freq, obj_size);\n        auto pqit = priority_set.insert({pri, ts, obj_id}).first;\n        cache_map[obj_id] = {freq, obj_size, ts, pqit};\n    }\n\n    obj_id_t evict() {\n        if (priority_set.empty()) return 0;\n        auto it = priority_set.begin();\n        obj_id_t victim = std::get<2>(*it);\n        last_evict_pri = std::get<0>(*it);\n        priority_set.erase(it);\n        cache_map.erase(victim);\n\n        // Aging: halve the frequency of all remaining cache objects (minimum 1), to prevent stale objects from dominating.\n        // This helps adapt to evolving workloads, giving new objects a chance.\n        std::vector<std::tuple<double, uint64_t, obj_id_t>> to_reinsert;\n        for (auto& kv : cache_map) {\n            auto& obj = kv.second;\n            // Remove old entry from priority_set\n            priority_set.erase(obj.pqit);\n            // Age freq: halve, but minimum 1\n            if (obj.freq > 1) obj.freq = (obj.freq + 1) / 2;\n            double new_pri = calc_pri(obj.freq, obj.size);\n            obj.timestamp = ++counter;\n            to_reinsert.emplace_back(new_pri, obj.timestamp, kv.first);\n        }\n        for (auto& tup : to_reinsert) {\n            auto pqit = priority_set.insert(tup).first;\n            cache_map[std::get<2>(tup)].pqit = pqit;\n        }\n\n        return victim;\n    }\n};", "language": "python", "parent_id": "b17f69d5-3cf3-4eb7-b948-0fd3de9af97c", "generation": 4, "timestamp": 1763753544.5034688, "iteration_found": 61, "metrics": {"combined_score": -Infinity}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 11 lines with 29 lines", "parent_metrics": {"combined_score": -Infinity}, "island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}