{"id": "edb66aa1-fd8d-44d5-82a3-c0cd1c086847", "code": "#include <cstdint>\n#include <unordered_map>\n#include <set>\n\ntypedef uint64_t obj_id_t;\n\n// Hybrid GDSF (Greedy-Dual-Size-Frequency) with hot-spot boost for re-inserted objects\nclass CacheManager {\nprivate:\n    struct Node {\n        double priority;\n        uint64_t timestamp;\n        uint64_t freq;\n        uint64_t size;\n        obj_id_t id;\n        bool operator<(const Node& other) const {\n            if (priority != other.priority) return priority < other.priority;\n            return timestamp < other.timestamp;\n        }\n    };\n    std::unordered_map<obj_id_t, std::set<Node>::iterator> obj2iter;\n    std::unordered_map<obj_id_t, std::pair<uint64_t, uint64_t>> obj2freqsize; // id -> (freq, size)\n    std::set<Node> pq;\n    double last_evict_pri = 0.0;\n    uint64_t ts = 0;\n\n    // Hotness bonus for objects that are already present, to bias slightly toward recency/hotspot\n    double calc_priority(uint64_t freq, uint64_t size, bool boost) {\n        if (size == 0) size = 1;\n        double p = last_evict_pri + (double(freq) * 1.0e6 / double(size));\n        if (boost) p += 1.0e4;\n        return p;\n    }\n\npublic:\n    bool find(obj_id_t obj_id) {\n        auto it = obj2iter.find(obj_id);\n        if (it == obj2iter.end()) return false;\n        Node old_node = *(it->second);\n        pq.erase(it->second);\n        old_node.freq += 1;\n        old_node.timestamp = ++ts;\n        double pri = calc_priority(old_node.freq, old_node.size, true);\n        Node new_node = {pri, old_node.timestamp, old_node.freq, old_node.size, obj_id};\n        auto iter = pq.insert(new_node).first;\n        obj2iter[obj_id] = iter;\n        obj2freqsize[obj_id] = std::make_pair(old_node.freq, old_node.size);\n        return true;\n    }\n\n    void insert(obj_id_t obj_id, uint64_t obj_size) {\n        auto it = obj2iter.find(obj_id);\n        if (it != obj2iter.end()) {\n            // Hot-spot: acts as a find+priority-boost\n            find(obj_id);\n            return;\n        }\n        uint64_t freq = 1;\n        uint64_t cur_ts = ++ts;\n        double pri = calc_priority(freq, obj_size, false);\n        Node node = {pri, cur_ts, freq, obj_size, obj_id};\n        auto iter = pq.insert(node).first;\n        obj2iter[obj_id] = iter;\n        obj2freqsize[obj_id] = std::make_pair(freq, obj_size);\n    }\n\n    obj_id_t evict() {\n        if (pq.empty()) return 0;\n        auto it = pq.begin();\n        obj_id_t victim = it->id;\n        last_evict_pri = it->priority;\n        pq.erase(it);\n        obj2iter.erase(victim);\n        obj2freqsize.erase(victim);\n        return victim;\n    }\n};", "language": "python", "parent_id": "d9eb4fde-4be1-4f2d-ad39-541b3c340731", "generation": 3, "timestamp": 1763754041.6874247, "iteration_found": 79, "metrics": {"combined_score": -Infinity}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 60 lines with 77 lines", "parent_metrics": {"combined_score": -Infinity}, "island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}