{"id": "532215df-e1c9-4611-91ab-fcd8adbe4e76", "code": "#include <cstdint>\n#include <unordered_map>\n#include <set>\n\ntypedef uint64_t obj_id_t;\n\n// LFU+Size-Aware: Uses frequency, but for ties, prefers to evict LARGER objects (so we keep small hot objects).\nclass CacheManager {\nprivate:\n    struct LFUNode {\n        uint64_t freq;\n        uint64_t timestamp; // for LRU tiebreak\n        uint64_t size;\n        obj_id_t obj_id;\n        LFUNode(uint64_t f, uint64_t ts, uint64_t s, obj_id_t id) : freq(f), timestamp(ts), size(s), obj_id(id) {}\n        // Set ordering: freq, then size descending (evict big on tie), then timestamp, then obj_id\n        bool operator<(const LFUNode &o) const {\n            if (freq != o.freq) return freq < o.freq;\n            if (size != o.size) return size > o.size; // prefer to evict bigger object on tie\n            if (timestamp != o.timestamp) return timestamp < o.timestamp;\n            return obj_id < o.obj_id;\n        }\n    };\n\n    std::unordered_map<obj_id_t, std::set<LFUNode>::iterator> obj2iter;\n    std::set<LFUNode> lfu_set;\n    std::unordered_map<obj_id_t, uint64_t> obj2size;\n    uint64_t time_counter = 0;\n\npublic:\n    bool find(obj_id_t obj_id) {\n        auto it = obj2iter.find(obj_id);\n        if (it == obj2iter.end()) return false;\n        auto node = *(it->second);\n        lfu_set.erase(it->second);\n        node.freq += 1;\n        node.timestamp = ++time_counter;\n        auto iter = lfu_set.insert(LFUNode(node.freq, node.timestamp, node.size, node.obj_id)).first;\n        obj2iter[obj_id] = iter;\n        obj2size[obj_id] = node.size; // ensure consistency if ever updated\n        return true;\n    }\n\n    void insert(obj_id_t obj_id, uint64_t obj_size) {\n        auto it = obj2iter.find(obj_id);\n        if (it != obj2iter.end()) {\n            find(obj_id);\n            return;\n        }\n        LFUNode node(1, ++time_counter, obj_size, obj_id);\n        auto iter = lfu_set.insert(node).first;\n        obj2iter[obj_id] = iter;\n        obj2size[obj_id] = obj_size;\n    }\n\n    obj_id_t evict() {\n        if (lfu_set.empty()) return 0;\n        auto it = lfu_set.begin();\n        obj_id_t victim = it->obj_id;\n        lfu_set.erase(it);\n        obj2iter.erase(victim);\n        obj2size.erase(victim);\n\n        // Slight frequency aging after every eviction to prevent stale objects dominating\n        // and to provide diversity in object survival\n        // (This is lightweight: reduce all frequencies by 1, but not below 1)\n        std::vector<std::pair<obj_id_t, LFUNode>> need_update;\n        for (auto &kv : obj2iter) {\n            auto setit = kv.second;\n            LFUNode node = *setit;\n            if (node.freq > 1) {\n                lfu_set.erase(setit);\n                node.freq -= 1;\n                // Keep timestamp and size the same (only freq changed)\n                auto newit = lfu_set.insert(node).first;\n                need_update.emplace_back(node.obj_id, node);\n                kv.second = newit;\n            }\n        }\n        // No need to update obj2size; it's only for bookkeeping of sizes\n\n        return victim;\n    }\n};", "language": "python", "parent_id": "f407eb59-cc43-4eae-87a4-56deb0f49a6f", "generation": 3, "timestamp": 1763752761.404005, "iteration_found": 19, "metrics": {"combined_score": -Infinity}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 23 lines with 24 lines\nChange 2: Replace 10 lines with 29 lines", "parent_metrics": {"combined_score": -Infinity}, "island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}