{"id": "9372bb8e-33ca-4ba2-8816-b5c07fe518ce", "code": "#include <cstdint>\n#include <unordered_map>\n#include <set>\n\ntypedef uint64_t obj_id_t;\n\n// Greedy-Dual-Size-Frequency (GDSF)-inspired cache: object priority = L + freq/size (L is last evict's priority).\n// This balances frequency, size, and aging, protecting small hot objects while demoting stale ones.\nclass CacheManager {\nprivate:\n    struct Node {\n        double priority;\n        uint64_t time;\n        obj_id_t id;\n        uint64_t freq;\n        uint64_t size;\n        Node(double p, uint64_t t, obj_id_t i, uint64_t f, uint64_t s)\n            : priority(p), time(t), id(i), freq(f), size(s) {}\n        bool operator<(const Node& o) const {\n            if (priority != o.priority) return priority < o.priority;\n            if (time != o.time) return time < o.time;\n            return id < o.id;\n        }\n    };\n    std::unordered_map<obj_id_t, std::set<Node>::iterator> lookup;\n    std::set<Node> pq;\n    uint64_t tick = 0;\n    double last_L = 0.0;\n\n    double calc_priority(uint64_t freq, uint64_t size) const {\n        if (size == 0) return last_L + double(freq) * 1e6; // Avoid div by zero; arbitrary high priority for small hot object\n        return last_L + double(freq) * 1e6 / double(size);\n    }\n\npublic:\n    bool find(obj_id_t obj_id) {\n        auto it = lookup.find(obj_id);\n        if (it == lookup.end()) return false;\n        Node old = *(it->second);\n        pq.erase(it->second);\n        uint64_t new_freq = old.freq + 1;\n        double new_pri = calc_priority(new_freq, old.size);\n        Node upd(new_pri, ++tick, old.id, new_freq, old.size);\n        auto iter = pq.insert(upd).first;\n        lookup[obj_id] = iter;\n        return true;\n    }\n\n    void insert(obj_id_t obj_id, uint64_t obj_size) {\n        if (lookup.count(obj_id)) {\n            find(obj_id);\n            return;\n        }\n        uint64_t freq = 1;\n        double pri = calc_priority(freq, obj_size);\n        Node n(pri, ++tick, obj_id, freq, obj_size);\n        auto iter = pq.insert(n).first;\n        lookup[obj_id] = iter;\n    }\n\n    obj_id_t evict() {\n        if (pq.empty()) return 0;\n        auto victim = pq.begin();\n        obj_id_t vid = victim->id;\n        last_L = victim->priority;\n        pq.erase(victim);\n        lookup.erase(vid);\n        return vid;\n    }\n};", "language": "python", "parent_id": "f4973449-fea8-4a8d-84eb-4413f3bbe84b", "generation": 3, "timestamp": 1763752935.6397939, "iteration_found": 29, "metrics": {"combined_score": -Infinity}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 58 lines with 70 lines", "parent_metrics": {"combined_score": -Infinity}, "island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}