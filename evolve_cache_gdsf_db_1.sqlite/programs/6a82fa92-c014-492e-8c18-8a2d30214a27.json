{"id": "6a82fa92-c014-492e-8c18-8a2d30214a27", "code": "#include <cstdint>\n#include <unordered_map>\n#include <set>\n#include <vector>\n\ntypedef uint64_t obj_id_t;\n\n/*\n * LFU+Size-Aware: Uses frequency, but for ties, prefers to evict LARGER objects (so we keep small hot objects).\n * Enhancement: Add lightweight frequency aging on eviction (decay freq counts on ALL entries),\n * which helps avoid stale objects being protected forever, boosting recency and adaptability.\n */\nclass CacheManager {\nprivate:\n    struct LFUNode {\n        uint64_t freq;\n        uint64_t timestamp; // for LRU tiebreak\n        uint64_t size;\n        obj_id_t obj_id;\n        LFUNode(uint64_t f, uint64_t ts, uint64_t s, obj_id_t id) : freq(f), timestamp(ts), size(s), obj_id(id) {}\n        // Set ordering: freq, then size descending (evict big on tie), then timestamp, then obj_id\n        bool operator<(const LFUNode &o) const {\n            if (freq != o.freq) return freq < o.freq;\n            if (size != o.size) return size > o.size; // prefer to evict bigger object on tie\n            if (timestamp != o.timestamp) return timestamp < o.timestamp;\n            return obj_id < o.obj_id;\n        }\n    };\n\n    std::unordered_map<obj_id_t, std::set<LFUNode>::iterator> obj2iter;\n    std::set<LFUNode> lfu_set;\n    std::unordered_map<obj_id_t, uint64_t> obj2size;\n    uint64_t time_counter = 0;\n\n    // Frequency aging: After each eviction, decay (halve) all frequencies > 1 for all objects.\n    // MODIFIED: Only age frequencies for objects with frequency >= 4 and only if set is \"large\"\n    //           to reduce churn and preserve hot objects when cache is small.\n    void age_all_frequencies() {\n        constexpr uint64_t k_min_age_freq = 4;\n        constexpr size_t k_age_threshold = 32;\n        if (lfu_set.size() < k_age_threshold) return;\n        std::vector<LFUNode> updated_nodes;\n        for (auto it = lfu_set.begin(); it != lfu_set.end(); ++it) {\n            LFUNode n = *it;\n            if (n.freq >= k_min_age_freq) n.freq = (n.freq + 1) / 2;\n            updated_nodes.push_back(n);\n        }\n        lfu_set.clear();\n        obj2iter.clear();\n        for (const auto& n : updated_nodes) {\n            auto iter = lfu_set.insert(n).first;\n            obj2iter[n.obj_id] = iter;\n            obj2size[n.obj_id] = n.size;\n        }\n    }\n\npublic:\n    // On hit, add a small \"bonus\" to freq for truly hot objects, only if freq already large.\n    bool find(obj_id_t obj_id) {\n        auto it = obj2iter.find(obj_id);\n        if (it == obj2iter.end()) return false;\n        auto node = *(it->second);\n        lfu_set.erase(it->second);\n        // If freq is \"very hot\" (>=8), add bonus of 2 to accelerate prioritization\n        if (node.freq >= 8)\n            node.freq += 2;\n        else\n            node.freq += 1;\n        node.timestamp = ++time_counter;\n        auto iter = lfu_set.insert(LFUNode(node.freq, node.timestamp, node.size, node.obj_id)).first;\n        obj2iter[obj_id] = iter;\n        // Don't touch obj2size (never changes here)\n        return true;\n    }\n\n    void insert(obj_id_t obj_id, uint64_t obj_size) {\n        auto it = obj2iter.find(obj_id);\n        if (it != obj2iter.end()) {\n            find(obj_id);\n            return;\n        }\n        LFUNode node(1, ++time_counter, obj_size, obj_id);\n        auto iter = lfu_set.insert(node).first;\n        obj2iter[obj_id] = iter;\n        obj2size[obj_id] = obj_size;\n    }\n\n    obj_id_t evict() {\n        if (lfu_set.empty()) return 0;\n        auto it = lfu_set.begin();\n        obj_id_t victim = it->obj_id;\n        // Record freq of evicted to guide aging more adaptively (age more if evicting high-freq obj)\n        uint64_t evict_freq = it->freq;\n        lfu_set.erase(it);\n        obj2iter.erase(victim);\n        obj2size.erase(victim);\n        // If the evicted object's freq was high, be more aggressive with aging\n        if (evict_freq >= 8) {\n            // lower age threshold and min_age_freq for this round\n            constexpr uint64_t k_min_age_freq = 2;\n            constexpr size_t k_age_threshold = 8;\n            if (lfu_set.size() >= k_age_threshold) {\n                std::vector<LFUNode> updated_nodes;\n                for (auto it2 = lfu_set.begin(); it2 != lfu_set.end(); ++it2) {\n                    LFUNode n = *it2;\n                    if (n.freq >= k_min_age_freq) n.freq = (n.freq + 1) / 2;\n                    updated_nodes.push_back(n);\n                }\n                lfu_set.clear();\n                obj2iter.clear();\n                for (const auto& n : updated_nodes) {\n                    auto iter = lfu_set.insert(n).first;\n                    obj2iter[n.obj_id] = iter;\n                    obj2size[n.obj_id] = n.size;\n                }\n            }\n        } else {\n            age_all_frequencies(); // only decay if set is large and entry was long-lived\n        }\n        return victim;\n    }\n};", "language": "python", "parent_id": "754e8110-6104-4309-9db2-1e2a13d8256a", "generation": 7, "timestamp": 1763754204.6554813, "iteration_found": 84, "metrics": {"combined_score": -Infinity}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 3 lines with 4 lines\nChange 2: Replace 12 lines with 17 lines\nChange 3: Replace 11 lines with 35 lines", "parent_metrics": {"combined_score": -Infinity}, "island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}