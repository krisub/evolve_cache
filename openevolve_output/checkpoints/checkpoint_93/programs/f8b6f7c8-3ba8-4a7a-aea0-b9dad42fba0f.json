{"id": "f8b6f7c8-3ba8-4a7a-aea0-b9dad42fba0f", "code": "#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * Variant: Piecewise scaling of priority for object size.\n   * - For very large objects (>2MB), penalize size more and emphasize log(freq).\n   * - For small objects (<=8KB), boost frequency and discount size penalty.\n   * - For others, use log2(freq+1) over sqrt(size) as before but slightly lower scale.\n   */\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + std::log2(freq+1) * 2.2e5;\n    }\n    if (size > 2*1024*1024) { // objects > 2MB\n      return pri_last_evict + std::log2(freq+1) * 2.4e5 / std::pow(size, 0.68);\n    }\n    if (size <= 8192) { // very small objects (<=8KB)\n      double freq_boost = freq + 2.5;\n      return pri_last_evict + std::pow(freq_boost, 1.08) * 2.15e5 / std::pow(size+1, 0.45);\n    }\n    // Default: log2-based frequency, sublinear size penalty\n    return pri_last_evict + std::log2(freq+1.3) * 1.88e5 / std::sqrt((double)size+8);\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // On insertion, grant virtual frequency bonuses:\n    // - Very small (<=8KB): +3\n    // - Small-medium (<=64KB): +2\n    // - Large (>2MB): +3\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size <= 8192)\n      adj_freq += 3;\n    else if (obj_size <= 65536)\n      adj_freq += 2;\n    else if (obj_size > 2*1024*1024)\n      adj_freq += 3;\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};", "language": "python", "parent_id": "18a6a9ab-1d40-4d40-a937-a688d6948bf7", "generation": 4, "timestamp": 1763087525.866041, "iteration_found": 85, "metrics": {"combined_score": 0.8525, "miss_ratio_4": 0.3606, "miss_ratio_45": 0.2935, "miss_ratio_450": 0.1475}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 20 lines with 22 lines\nChange 2: Replace 18 lines with 21 lines", "parent_metrics": {"combined_score": 0.8459, "miss_ratio_4": 0.3797, "miss_ratio_45": 0.2717, "miss_ratio_450": 0.1541}, "island": 2}, "prompts": {"diff_user": {"system": "You are an expert C++ programmer specializing in high-performance cache eviction algorithms.\nYour task is to implement a C++ class named `CacheManager`.\n\nYou MUST provide the complete, raw C++ code, starting with #include.\n\nCRITICAL: The generated code MUST end with the final '};' that closes the class.\n\nCRITICAL: The class MUST have three public methods with these EXACT signatures. DO NOT change them:\n- `bool find(obj_id_t obj_id)`\n- `void insert(obj_id_t obj_id, uint64_t obj_size)`\n- `obj_id_t evict()`\n\nThe class MUST NOT have a custom constructor. It must use the default constructor.\n\nHere is an example of the required structure. You can change the private members and the logic inside the functions, but NOT the public class name or method signatures.\n\n```cpp\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n* Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n*\n* This class manages the cache eviction state. It tracks objects,\n* their sizes, and their frequencies to calculate a priority for\n* eviction. It evicts the object with the *lowest* priority.\n*\n* Priority (H-value) is calculated as: L + (Frequency / Size)\n* where 'L' is the priority of the last evicted item.\n*/\nclass CacheManager {\nprivate:\n  /**\n  * Node stored in the priority queue (std::set).\n  *\n  * We use std::set as a min-priority queue. It stores nodes\n  * ordered by priority, then by a timestamp as a tie-breaker.\n  */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n  * Metadata for each object stored in the cache.\n  *\n  * Stored as the value in the main `cache_objects` map.\n  */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n  * Main lookup map.\n  *\n  * Maps an object's ID to its metadata (size, freq, and\n  * iterator into the priority queue).\n  */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n  * The priority queue.\n  *\n  * Implemented as an std::set to keep items sorted by priority\n  * and allow for efficient removal from anywhere in the queue.\n  * The item at `priority_queue.begin()` is the eviction victim.\n  */\n  std::set<PQNode> priority_queue;\n\n  /**\n  *  The 'L' value in GDSF.\n  *\n  * This is the priority of the last item that was evicted.\n  * It's used as the base priority for all new and re-prioritized items.\n  */\n  double pri_last_evict = 0.0;\n\n  /**\n  * A simple counter to use as a timestamp for tie-breaking.\n  *\n  * This ensures FIFO-like behavior for items with the same priority.\n  */\n  uint64_t request_counter = 0;\n\n  /**\n  * Helper function to calculate an object's priority (H-value).\n  *\n  * From the original code: pri = L + (freq * 1.0e6 / size)\n  * The 1.0e6 is a scaling factor to keep the (freq/size)\n  * component significant.\n  */\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + (double)(freq) * 1.0e6;\n    }\n    return pri_last_evict + (double)(freq) * 1.0e6 / size;\n  }\n\npublic:\n  /**\n  * Default constructor.\n  */\n  CacheManager() = default;\n\n  /**\n  * Finds an object in the cache.\n  *\n  * If the object is found, its frequency is incremented, its\n  * priority is recalculated, and its position in the\n  * priority queue is updated.\n  *\n  * @param obj_id The ID of the object to find.\n  * @return true if the object was found (a hit), false otherwise (a miss).\n  */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n  * Inserts a new object into the cache.\n  *\n  * Assumes this is called after a `find` reported a miss.\n  * If the object already exists, this function will behave\n  * like `find()` and update its priority.\n  *\n  * @param obj_id The ID of the object to insert.\n  * @param obj_size The size of the object (required for GDSF).\n  */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    double pri = calculate_priority(new_obj.frequency, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n  * Selects, removes, and returns the victim object to evict.\n  *\n  * The victim is the object with the *lowest* priority, which\n  * will be at the beginning of the `std::set`.\n  *\n  * @return The obj_id_t of the evicted object. Returns 0 if\n  * the cache is empty.\n  */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};\n```\n", "user": "# Current Program Information\n- Fitness: 0.8459\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.8484 \u2192 0.8459. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### full_results_json\n```\n{\"score\": 0.8459, \"results\": [{\"cache_name\": \"FullCodeEvolve\", \"cache_size_mb\": 4, \"n_miss\": 1243772, \"n_req\": 3275919, \"miss_ratio\": 0.3797, \"byte_miss_ratio\": 0.6418, \"runtime_seconds\": 10.471808}, {\"cache_name\": \"FullCodeEvolve\", \"cache_size_mb\": 45, \"n_miss\": 890040, \"n_req\": 3275919, \"miss_ratio\": 0.2717, \"byte_miss_ratio\": 0.4565, \"runtime_seconds\": 10.471808}, {\"cache_name\": \"FullCodeEvolve\", \"cache_size_mb\": 450, \"n_miss\": 504872, \"n_req\": 3275919, \"miss_ratio\": 0.1541, \"byte_miss_ratio\": 0.2432, \"runtime_seconds\": 10.471808}]}\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 6 lines with 8 lines\nChange 2: Replace 20 lines with 20 lines\n- Metrics: combined_score: 0.8484, miss_ratio_4: 0.3714, miss_ratio_45: 0.2657, miss_ratio_450: 0.1516\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 6 lines with 7 lines\nChange 2: Replace 10 lines with 13 lines\n- Metrics: combined_score: 0.8572, miss_ratio_4: 0.3590, miss_ratio_45: 0.2413, miss_ratio_450: 0.1428\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: combined_score: 0.8572, miss_ratio_4: 0.3590, miss_ratio_45: 0.2413, miss_ratio_450: 0.1428\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.8572)\n```python\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * From the original code: pri = L + (freq * 1.0e6 / size)\n   * The 1.0e6 is a scaling factor to keep the (freq/size)\n   * component significant.\n   */\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + (double)(freq) * 1.0e6;\n    }\n    return pri_last_evict + (double)(freq) * 1.0e6 / size;\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    double pri = calculate_priority(new_obj.frequency, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};\n```\nKey features: Performs well on combined_score (0.8572), Performs well on miss_ratio_4 (0.3590), Performs well on miss_ratio_45 (0.2413), Performs well on miss_ratio_450 (0.1428)\n\n### Program 2 (Score: 0.8572)\n```python\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * From the original code: pri = L + (freq * 1.0e6 / size)\n   * The 1.0e6 is a scaling factor to keep the (freq/size)\n   * component significant.\n   */\n  // Reduce scaling factor from 1.0e6 to 1.0e5 for finer priority differences with large object sizes\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + (double)(freq) * 1.0e5;\n    }\n    return pri_last_evict + (double)(freq) * 1.0e5 / size;\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // Use current pri_last_evict for new insertions, but for large objects, boost their initial frequency for fairness\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size > 1024 * 1024) adj_freq += 2; // Simple bonus for large objects (e.g., >1MB)\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};\n```\nKey features: Performs well on combined_score (0.8572), Performs well on miss_ratio_4 (0.3590), Performs well on miss_ratio_45 (0.2413), Performs well on miss_ratio_450 (0.1428)\n\n### Program 3 (Score: 0.8484)\n```python\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * From the original code: pri = L + (freq * 1.0e6 / size)\n   * The 1.0e6 is a scaling factor to keep the (freq/size)\n   * component significant.\n   */\n  // Reduce scaling factor from 1.0e6 to 1.0e5 for finer priority differences with large object sizes\n  // Apply a logarithmic scale to frequency and a square-root scale to object size for improved discrimination of long-lived, medium-size objects\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + std::log2(freq+1) * 2.0e5;\n    }\n    // Scaling factors: log2 for freq, sqrt for size, keep 2.0e5 as main scale\n    return pri_last_evict + std::log2(freq+1) * 2.0e5 / std::sqrt((double)size);\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // On insertion, give a slight frequency bonus for objects <= 4KB to aid small-but-frequently-used objects\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size <= 4096) adj_freq += 2; // bonus for small objects (<=4KB)\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};\n```\nKey features: Performs well on combined_score (0.8484), Performs well on miss_ratio_4 (0.3714), Performs well on miss_ratio_45 (0.2657), Performs well on miss_ratio_450 (0.1516)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.8456)\n```python\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * From the original code: pri = L + (freq * 1.0e6 / size)\n   * The 1.0e6 is a scaling factor to keep the (freq/size)\n   * component significant.\n   */\n  // Hybrid priority: logarithmic frequency, sublinear size penalty\n  // Small objects get more frequency bonus, large objects get heavier size penalty\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + std::log2(freq + 1) * 1.5e5;\n    }\n    if (size <= 4096) {\n      // Strong frequency boost for very small objects (<=4KB)\n      return pri_last_evict + std::pow(freq + 1.0, 1.15) * 1.4e5 / std::sqrt(size + 1);\n    }\n    if (size > 1024 * 1024) {\n      // Large objects, log-based frequency and heavy penalty on size\n      return pri_last_evict + std::log2(freq + 1.0) * 1.2e5 / std::pow(size, 0.85);\n    }\n    // Default hybrid for other cases\n    return pri_last_evict + std::log2(freq + 1.0) * 1.0e5 / std::pow(size, 0.7);\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // Hybrid insertion \"virtual frequency\" bonus:\n    // - Very small objects get bonus (+2)\n    // - Medium-small (<=64KB) get (+1)\n    // - Large objects (>1MB) get +2\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size <= 4096) adj_freq += 2;\n    else if (obj_size <= 65536) adj_freq += 1;\n    else if (obj_size > 1024 * 1024) adj_freq += 2;\n\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};\n```\nKey features: Alternative approach to combined_score, Alternative approach to miss_ratio_4\n\n### Program D2 (Score: 0.8459)\n```python\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * This version adds a moderate frequency bonus for large objects, mild boost for small objects, \n   * and more discrimination for mid-size objects to maintain a diverse mix and penalize cache flooding.\n   */\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + std::log2(freq+1) * 2.1e5;\n    }\n    // Mildly boost small object (<=4KB) and large object (>1MB) frequency for insertion and promotion.\n    double scale = 2.0e5;\n    double freq_adj = freq;\n    if (size <= 4096)\n      freq_adj += 1.5; // Mild, not as strong as insert bonus, but applies to all priorities\n    else if (size > 1024*1024)\n      freq_adj += 1.8; // Large object, moderate bias so hot large objects survive longer\n    // Sqrt for size makes size penalty strong for huge objects, mild for mid-size.\n    return pri_last_evict + std::log2(freq_adj+1) * scale / std::sqrt((double)size);\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // On insertion, give a frequency bonus for very small, very large, and modest for medium-small objects.\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size <= 4096)\n      adj_freq += 2;\n    else if (obj_size <= 65536)\n      adj_freq += 1;\n    else if (obj_size > 1024*1024)\n      adj_freq += 2;\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};\n```\nKey features: Alternative approach to combined_score, Alternative approach to miss_ratio_4\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.8572, Type: High-Performer)\n```python\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * From the original code: pri = L + (freq * 1.0e6 / size)\n   * The 1.0e6 is a scaling factor to keep the (freq/size)\n   * component significant.\n   */\n  // Reduce scaling factor from 1.0e6 to 1.0e5 for finer priority differences with large object sizes\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + (double)(freq) * 1.0e5;\n    }\n    return pri_last_evict + (double)(freq) * 1.0e5 / size;\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // Use current pri_last_evict for new insertions, but for large objects, boost their initial frequency for fairness\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size > 1024 * 1024) adj_freq += 2; // Simple bonus for large objects (e.g., >1MB)\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};\n```\nUnique approach: Modification: Change 1: Replace 6 lines with 7 lines\nChange 2: Replace 10 lines with 13 lines, Alternative miss_ratio_45 approach, Alternative miss_ratio_450 approach\n\n### Inspiration 2 (Score: 0.8454, Type: High-Performer)\n```python\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * Priority formula (piecewise):\n   * - For very large objects (>1MB): use log2(frequency+1) with heavier size penalty (log2(size+2))\n   * - For very small objects (<=4KB): boost frequency non-linearly, penalize size lightly\n   * - Otherwise: hybrid log-frequency over sublinear size\n   */\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    constexpr double SCALE_LARGE = 4.0e5, SCALE_SMALL = 2.0e5, SCALE_NORMAL = 1.2e5;\n    if (size == 0) {\n      return pri_last_evict + freq * SCALE_NORMAL;\n    }\n    if (size > 1024*1024) {\n      // Very large objects: use slightly stronger frequency and heavier size penalty\n      return pri_last_evict + std::pow(std::log2(freq + 2.0), 1.12) * SCALE_LARGE / std::pow(std::log2(size + 16.0), 1.1);\n    }\n    if (size <= 4096) {\n      // Very small objects: boost for freq, less penalty for size (slightly increased exponent for better promotion of hot small objects)\n      return pri_last_evict + std::pow(freq + 1.7, 1.22) * (SCALE_SMALL+6000) / std::pow(size + 8.0, 0.48);\n    }\n    // Hybrid for other sizes: log2 frequency, sublinear size penalty\n    return pri_last_evict + std::log2(freq + 1.0) * (SCALE_NORMAL + 2500) / std::pow((double)size + 8.0, 0.73);\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // On insertion, assign a virtual frequency bonus:\n    // - Large objects get a small bonus (+2), small objects (+3), medium objects (+1)\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size > 1024 * 1024) adj_freq += 2;\n    else if (obj_size <= 4096) adj_freq += 3;\n    else if (obj_size <= 65536) adj_freq += 1;\n\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};\n```\nUnique approach: Modification: Change 1: Replace 16 lines with 16 lines\nChange 2: Replace 13 lines with 13 lines, Alternative miss_ratio_45 approach, Alternative miss_ratio_450 approach\n\n### Inspiration 3 (Score: 0.8455, Type: High-Performer)\n```python\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * From the original code: pri = L + (freq * 1.0e6 / size)\n   * The 1.0e6 is a scaling factor to keep the (freq/size)\n   * component significant.\n   * \n   * This variant uses a piecewise scaling:\n   * - For objects > 1MB, emphasize frequency and penalize size (use log2(freq+1) / log2(size+2))\n   * - For objects <= 4KB, strongly boost frequency (freq^1.2 / sqrt(size+1))\n   * - Otherwise, use hybrid: (freq+1) / (size^0.75)\n   */\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    constexpr double L1 = 1.0e5, L2 = 4.0e5, L3 = 2.0e5;\n    if (size == 0) return pri_last_evict + freq * L1; // degenerate case\n    \n    if (size > 1024*1024) {\n      // Very large objects: bias towards frequency but penalize size more\n      return pri_last_evict + std::log2(freq + 1.0) * L2 / std::log2(size + 2.0);\n    } else if (size <= 4096) {\n      // Very small objects: boost for freq, less penalty for size\n      return pri_last_evict + std::pow(freq + 1.0, 1.2) * L3 / std::sqrt(size + 1.0);\n    } else {\n      // Hybrid for the rest\n      return pri_last_evict + (freq + 1.0) * L1 / std::pow(size, 0.75);\n    }\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // Piecewise \"insertion bonus\" for certain object sizes:\n    // - Large objects get a virtual freq boost (but not too much)\n    // - Small objects get a slightly higher virtual freq\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size > 1024 * 1024) adj_freq += 3;\n    else if (obj_size <= 4096) adj_freq += 2;\n    else if (obj_size <= 65536) adj_freq += 1;\n\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};\n```\nUnique approach: Modification: Change 1: Replace 16 lines with 27 lines\nChange 2: Replace 20 lines with 25 lines, Alternative miss_ratio_45 approach, Alternative miss_ratio_450 approach\n\n# Current Program\n```python\n#include <cstdint>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <unordered_map>\n\ntypedef uint64_t obj_id_t;\n\n/**\n * Implements the Greedy-Dual-Size-Frequency (GDSF) eviction policy.\n *\n * This class manages the cache eviction state. It tracks objects,\n * their sizes, and their frequencies to calculate a priority for\n * eviction. It evicts the object with the *lowest* priority.\n *\n * Priority (H-value) is calculated as: L + (Frequency / Size)\n * where 'L' is the priority of the last evicted item.\n */\nclass CacheManager {\nprivate:\n  /**\n   * Node stored in the priority queue (std::set).\n   *\n   * We use std::set as a min-priority queue. It stores nodes\n   * ordered by priority, then by a timestamp as a tie-breaker.\n   */\n  struct PQNode {\n    double priority;\n    uint64_t timestamp; // Tie-breaker, incremented on each access\n    obj_id_t id;\n\n    // Constructor\n    PQNode(double p, uint64_t ts, obj_id_t i)\n        : priority(p), timestamp(ts), id(i) {}\n\n    // Comparison operator for std::set\n    // Orders by priority (lowest first), then timestamp\n    bool operator<(const PQNode &other) const {\n      if (priority != other.priority) {\n        return priority < other.priority;\n      }\n      return timestamp < other.timestamp;\n    }\n  };\n\n  /**\n   * Metadata for each object stored in the cache.\n   *\n   * Stored as the value in the main `cache_objects` map.\n   */\n  struct CacheObject {\n    uint64_t size;\n    uint64_t frequency;\n    // An iterator pointing to this object's entry in the\n    // priority_queue set. This allows for O(log N) removal\n    // during a `find` operation.\n    std::set<PQNode>::iterator pq_iterator;\n  };\n\n  /**\n   * Main lookup map.\n   *\n   * Maps an object's ID to its metadata (size, freq, and\n   * iterator into the priority queue).\n   */\n  std::unordered_map<obj_id_t, CacheObject> cache_objects;\n\n  /**\n   * The priority queue.\n   *\n   * Implemented as an std::set to keep items sorted by priority\n   * and allow for efficient removal from anywhere in the queue.\n   * The item at `priority_queue.begin()` is the eviction victim.\n   */\n  std::set<PQNode> priority_queue;\n\n  /**\n   *  The 'L' value in GDSF.\n   *\n   * This is the priority of the last item that was evicted.\n   * It's used as the base priority for all new and re-prioritized items.\n   */\n  double pri_last_evict = 0.0;\n\n  /**\n   * A simple counter to use as a timestamp for tie-breaking.\n   *\n   * This ensures FIFO-like behavior for items with the same priority.\n   */\n  uint64_t request_counter = 0;\n\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * This version adds a moderate frequency bonus for large objects, mild boost for small objects, \n   * and more discrimination for mid-size objects to maintain a diverse mix and penalize cache flooding.\n   */\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + std::log2(freq+1) * 2.1e5;\n    }\n    // Mildly boost small object (<=4KB) and large object (>1MB) frequency for insertion and promotion.\n    double scale = 2.0e5;\n    double freq_adj = freq;\n    if (size <= 4096)\n      freq_adj += 1.5; // Mild, not as strong as insert bonus, but applies to all priorities\n    else if (size > 1024*1024)\n      freq_adj += 1.8; // Large object, moderate bias so hot large objects survive longer\n    // Sqrt for size makes size penalty strong for huge objects, mild for mid-size.\n    return pri_last_evict + std::log2(freq_adj+1) * scale / std::sqrt((double)size);\n  }\n\npublic:\n  /**\n   * Default constructor.\n   */\n  CacheManager() = default;\n\n  /**\n   * Finds an object in the cache.\n   *\n   * If the object is found, its frequency is incremented, its\n   * priority is recalculated, and its position in the\n   * priority queue is updated.\n   *\n   * @param obj_id The ID of the object to find.\n   * @return true if the object was found (a hit), false otherwise (a miss).\n   */\n  bool find(obj_id_t obj_id) {\n    auto map_iter = cache_objects.find(obj_id);\n\n    if (map_iter == cache_objects.end()) {\n      return false;\n    }\n\n    CacheObject &obj = map_iter->second;\n    priority_queue.erase(obj.pq_iterator);\n    obj.frequency += 1;\n    double new_pri = calculate_priority(obj.frequency, obj.size);\n\n    PQNode new_node(new_pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    obj.pq_iterator = set_iter;\n\n    return true;\n  }\n\n  /**\n   * Inserts a new object into the cache.\n   *\n   * Assumes this is called after a `find` reported a miss.\n   * If the object already exists, this function will behave\n   * like `find()` and update its priority.\n   *\n   * @param obj_id The ID of the object to insert.\n   * @param obj_size The size of the object (required for GDSF).\n   */\n  void insert(obj_id_t obj_id, uint64_t obj_size) {\n    if (cache_objects.count(obj_id)) {\n      find(obj_id);\n      return;\n    }\n\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // On insertion, give a frequency bonus for very small, very large, and modest for medium-small objects.\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size <= 4096)\n      adj_freq += 2;\n    else if (obj_size <= 65536)\n      adj_freq += 1;\n    else if (obj_size > 1024*1024)\n      adj_freq += 2;\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n  }\n\n  /**\n   * Selects, removes, and returns the victim object to evict.\n   *\n   * The victim is the object with the *lowest* priority, which\n   * will be at the beginning of the `std::set`.\n   *\n   * @return The obj_id_t of the evicted object. Returns 0 if\n   * the cache is empty.\n   */\n  obj_id_t evict() {\n    if (priority_queue.empty()) {\n      return 0;\n    }\n\n    auto victim_node_it = priority_queue.begin();\n    obj_id_t victim_id = victim_node_it->id;\n    double victim_priority = victim_node_it->priority;\n\n    cache_objects.erase(victim_id);\n    priority_queue.erase(victim_node_it);\n    pri_last_evict = victim_priority;\n\n    return victim_id;\n  }\n};\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * This version adds a moderate frequency bonus for large objects, mild boost for small objects, \n   * and more discrimination for mid-size objects to maintain a diverse mix and penalize cache flooding.\n   */\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + std::log2(freq+1) * 2.1e5;\n    }\n    // Mildly boost small object (<=4KB) and large object (>1MB) frequency for insertion and promotion.\n    double scale = 2.0e5;\n    double freq_adj = freq;\n    if (size <= 4096)\n      freq_adj += 1.5; // Mild, not as strong as insert bonus, but applies to all priorities\n    else if (size > 1024*1024)\n      freq_adj += 1.8; // Large object, moderate bias so hot large objects survive longer\n    // Sqrt for size makes size penalty strong for huge objects, mild for mid-size.\n    return pri_last_evict + std::log2(freq_adj+1) * scale / std::sqrt((double)size);\n  }\n=======\n  /**\n   * Helper function to calculate an object's priority (H-value).\n   *\n   * Variant: Piecewise scaling of priority for object size.\n   * - For very large objects (>2MB), penalize size more and emphasize log(freq).\n   * - For small objects (<=8KB), boost frequency and discount size penalty.\n   * - For others, use log2(freq+1) over sqrt(size) as before but slightly lower scale.\n   */\n  double calculate_priority(uint64_t freq, uint64_t size) {\n    if (size == 0) {\n      return pri_last_evict + std::log2(freq+1) * 2.2e5;\n    }\n    if (size > 2*1024*1024) { // objects > 2MB\n      return pri_last_evict + std::log2(freq+1) * 2.4e5 / std::pow(size, 0.68);\n    }\n    if (size <= 8192) { // very small objects (<=8KB)\n      double freq_boost = freq + 2.5;\n      return pri_last_evict + std::pow(freq_boost, 1.08) * 2.15e5 / std::pow(size+1, 0.45);\n    }\n    // Default: log2-based frequency, sublinear size penalty\n    return pri_last_evict + std::log2(freq+1.3) * 1.88e5 / std::sqrt((double)size+8);\n  }\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // On insertion, give a frequency bonus for very small, very large, and modest for medium-small objects.\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size <= 4096)\n      adj_freq += 2;\n    else if (obj_size <= 65536)\n      adj_freq += 1;\n    else if (obj_size > 1024*1024)\n      adj_freq += 2;\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n=======\n    CacheObject new_obj;\n    new_obj.size = obj_size;\n    new_obj.frequency = 1;\n\n    // On insertion, grant virtual frequency bonuses:\n    // - Very small (<=8KB): +3\n    // - Small-medium (<=64KB): +2\n    // - Large (>2MB): +3\n    uint64_t adj_freq = new_obj.frequency;\n    if (obj_size <= 8192)\n      adj_freq += 3;\n    else if (obj_size <= 65536)\n      adj_freq += 2;\n    else if (obj_size > 2*1024*1024)\n      adj_freq += 3;\n    double pri = calculate_priority(adj_freq, new_obj.size);\n    PQNode new_node(pri, ++request_counter, obj_id);\n    auto [set_iter, inserted] = priority_queue.insert(new_node);\n\n    new_obj.pq_iterator = set_iter;\n    cache_objects[obj_id] = new_obj;\n>>>>>>> REPLACE"]}}, "artifacts_json": "{\"full_results_json\": \"{\\\"score\\\": 0.8525, \\\"results\\\": [{\\\"cache_name\\\": \\\"FullCodeEvolve\\\", \\\"cache_size_mb\\\": 4, \\\"n_miss\\\": 1181213, \\\"n_req\\\": 3275919, \\\"miss_ratio\\\": 0.3606, \\\"byte_miss_ratio\\\": 0.6352, \\\"runtime_seconds\\\": 10.609534}, {\\\"cache_name\\\": \\\"FullCodeEvolve\\\", \\\"cache_size_mb\\\": 45, \\\"n_miss\\\": 961502, \\\"n_req\\\": 3275919, \\\"miss_ratio\\\": 0.2935, \\\"byte_miss_ratio\\\": 0.5675, \\\"runtime_seconds\\\": 10.609534}, {\\\"cache_name\\\": \\\"FullCodeEvolve\\\", \\\"cache_size_mb\\\": 450, \\\"n_miss\\\": 483221, \\\"n_req\\\": 3275919, \\\"miss_ratio\\\": 0.1475, \\\"byte_miss_ratio\\\": 0.2658, \\\"runtime_seconds\\\": 10.609534}]}\"}", "artifact_dir": null, "embedding": null}